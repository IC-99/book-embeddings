1: Enumerazione di 1-Page Book Embedding di Grafi Diretti Aciclici

2: l'obiettivo principale della tesi è la realizzazione di un algoritmo per enumerare tutti i possibili 1-page book embedding ammessi da un grafo diretto aciclico, anche detto DAG. Tale algoritmo è stato poi implementato in C++ e compilato in WebAssembly così da poter realizzare un tool efficiente che consente di utilizzare l'algoritmo su una pagina web. Un altro obiettivo della tesi consiste nel ricavare una formula per contare quanti sono i 1-page book embedding ammessi da un certo DAG.

3: un DAG è un grafo diretto privo di cicli diretti, dove non è possibile percorrere un cammino che attraversa più volte uno stesso vertice.

4: un book embedding di un DAG consiste in un disegno in cui i vertici del DAG sono ordinati lungo una linea, detta spina, e gli archi sono assegnati a diverse pagine con l'obiettivo di non avere incroci tra di essi. inoltre, poiché il DAG è un grafo diretto, l'ordinamento dei vertici deve rispettare la direzione degli archi.

5: un 1-page book embedding è un caso particolare dove tutti gli archi devono essere disegnati su una singola pagina senza incroci, mantenendo la corretta direzione.

6: per poter realizzare l'algoritmo di enumerazione è stato necessario studiare un algoritmo descritto da Heat e Pemmaraju più di 20 anni fa che verifica se un DAG ammette un 1-page book embedding. L'algoritmo è suddiviso in due fasi: nella prima fase viene verificato che ogni blocco del grafo ammetta un 1-page book embedding, nella seconda fase l'algoritmo tenta di combinare gli embedding dei blocchi per costruire un 1-page book embedding dell'intero DAG

7: la prima fase suddivide il DAG nelle sue componenti biconnesse, ovvero nei blocchi. un blocco è un sottografo massimale in cui la rimozione di un suo vertice non aumenta il numero di componenti connesse. i vertici che, se rimossi, aumentano il numero di componenti connesse del grafo sono detti cutpoint e sono evidenziati in rosso in questo DAG di esempio.

8: nella prima fase, l'algoritmo cerca quindi di ricavare il 1-page book embedding di ogni blocco del DAG. se invece viene trovato un blocco che non ammette un 1-page book embedding allora l'algoritmo fallisce.

9: la seconda fase utilizza un albero chiamato block-cutpoint tree. questo albero descrive la struttura del DAG ed è composto da nodi associati ai blocchi e ai cutpoint del DAG. Gli archi del block-cutpoint tree collegano i cutpoint ai blocchi a cui appartengono. L'albero viene radicato a un blocco arbitrario, e l'algoritmo cerca eventuali conflitti, vedremo più avanti cosa questo significa

10: se non vengono trovati conflitti, l’algoritmo elabora i blocchi in base a un ordinamento derivato da una visita in ampiezza del block-cutpoint tree.

11-18: L'elaborazione consiste nel combinare gli embedding dei blocchi passo dopo passo, aggiungendo l'embedding di ogni blocco a quello costruito finora. Quando tutti i blocchi sono stati elaborati, si ottiene un 1-page book embedding dell'intero DAG.

19: l'algoritmo di enumerazione proposto nella tesi si basa sull'algoritmo appena descritto. le prime fasi sono analoghe, dunque l'algoritmo verifica che ogni blocco ammetta un 1-page book embedding, radica il block-cutpoint tree a un blocco arbitrario e verifica che non ci siano conflitti. successivamente però, l'algoritmo introduce delle modifiche. per prima cosa viene ricercato un radicamento migliore per il block-cutpoint tree iniziale. poi vengono individuati i blocchi del DAG che se scambiati di posizione nel BFS ordering che genera il risultato portano a 1-page book embedding differenti. Quindi una volta individuati questi blocchi, vengono generati i diversi BFS ordering e, di conseguenza, costruiti i 1-page book embedding corrispondenti

20: prima di descrivere queste fasi, è utile definire le diverse tipologie di vertici nei blocchi. ogni blocco che ammette un 1-page book embedding ha un vertice sorgente senza archi in ingresso, un vertice pozzo senza archi in uscita e potrebbe avere anche vertici intermedi con archi sia in ingresso che in uscita

21: l'algoritmo etichetta gli archi del block-cutpoint tree in base al ruolo del cutpoint nel blocco a cui è collegato. 0 per sorgente, 1 per intermedio e 2 per pozzo

22: la ricerca di conflitti nel block-cutpoint tree può ora essere descritta poiché questa riguarda la ricerca di cammini tra blocchi in cui il primo e l'ultimo arco sono etichettati con 1. se un tale cammino esiste, allora il DAG non ammette un 1-page book embedding. Durante lo sviluppo della tesi è stata trovata un'imprecisione nell'algoritmo di heat e pemmaraju nella procedura che ricerca questi conflitti. La procedura è stata quindi corretta attraverso l'aggiunta di una condizione aggiuntiva

23: l'algoritmo procede con la ricerca di un radicamento migliore. la proprietà principale di tale radicamento risiede nel fatto che non sono presenti cutpoint che hanno blocchi figli raggiungibili attraverso un arco di tipo 1. questo radicamento esiste sempre nei block-cutpoint tree in cui non ci sono conflitti e può essere trovato in tempo lineare

24: un'ultima definizione utile è quella di cammino ristretto, un cammino ristretto è un cammino che ha origine in un cutpoint e che termina su un blocco attraverso un arco etichettato con 1

25: a questo punto è possibile individuare i blocchi che possono essere permutati tra loro per ottenere risultati differenti. tali blocchi permutabili risultano essere i blocchi collegati ad uno stesso cutpoint nel block-cutpoint tree attraverso archi dello stesso tipo, di tipo 0 o di tipo 2. L'unica eccezione risiede nei blocchi che si trovano su un cammino ristretto che ha origine nel cutpoint considerato. questi insiemi di blocchi possono essere individuati in tempo lineare

26: l'algoritmo quindi procede con la generazione di tutti i BFS ordering che contengono le diverse permutazioni dei blocchi individuati. questo viene fatto attraverso radicamenti alternativi del block-cutpoint tree e permutazioni di blocchi permutabili figli dei cutpoint. la generazione di un BFS ordering richiede tempo lineare e, come visto nell'algoritmo di Heat e Pemmaraju, anche la costruzione di un 1-page book embedding a partire da un BFS ordering richiede tempo lineare. dunque il delay temporale tra un risultato e il successivo dell'algoritmo di enumerazione è lineare rispetto al numero di vertici del DAG

27: Un altro risultato della tesi riguarda la formula che consente di contare tutti i possibili 1-page book embedding di un DAG qui riportata.

28-30: infine, dal punto di vista pratico è stato sviluppato un tool web che consente di eseguire l'algoritmo di enumerazione su una pagina web e di esplorarne i risultati. inoltre il numero di possibili risultati è calcolato attraverso la formula di counting e mostrato a schermo.


